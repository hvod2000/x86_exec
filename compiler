#!/usr/bin/env python3
from typing import List


# ---- GRAMMAR ----
# type var = expr
# var = expr
# if condition
#     ...
# else
#     ...
# def function()
#     ...


ids = 0
def get_uid():
    global ids
    ids += 1
    return ids - 1
types = {"int", "i8", "i8[]"}
variables = {}


def warnging(msg):
    print(f"\033[31mWARNING: {msg}\033[0m")

def tokenize(source: str):
    lines = source.split("\n")
    indents = [0]
    tokens = []
    for line in lines:
        indent = 0
        while indent < len(line) and line[indent] in " \t":
            indent += 1
        if indent > indents[-1]:
            indents.append(indent)
            tokens.append("INDENT")
        while indent < indents[-1]:
            tokens.append("DEINDENT")
            indents.pop()
        assert indents[-1] == indent
        tokens += [token for token in line[indent:].split(" ") if token]
    return tokens + ["END"]


def compile(source: str, target: str = "WINTER"):
    code = compile_statements(tokenize(source), 0)[1]
    if code.find("main:") != -1:
        if target == "WINTER":
            code = f"jmp main\n{code}halt:\njmp halt ;$E\n"
        else:
            code = f"jmp main\n{code}hlt\n"
    return code


def compile_statements(tokens, i):
    code = []
    while i < len(tokens) and tokens[i] not in {"END", "DEINDENT"}:
        i, line = compile_statement(tokens, i)
        code.append(line)
    return i, "".join(code)


def compile_statement(tokens: List[str], i: int):
    global variables
    if tokens[i] in types:
        return compile_declaration(tokens, i)
    elif tokens[i] == "def":
        label = tokens[i + 1].split("(", 1)[0]
        assert tokens[i + 2] == "INDENT"
        i, body = compile_statements(tokens, i + 3)
        return i + 1, f"{label}:\n" + body
    elif tokens[i] == "if":
        return compile_if(tokens, i)
    variable = tokens[i]
    if variable not in variables:
        warnging(f"variable {variable} is not defined")
    assert tokens[i + 1] == "="
    i, expr = compile_expression(tokens, i + 2, variables[variable])
    if variables[variable] == "int":
        return i, expr + f"pop ax\nmov {variable}, ax\n"
    return i, expr + f"pop al\nmov {variable}, al\n"


def compile_if(tokens, i):
    assert tokens[i] == "if"
    label = f"if_{get_uid()}"
    i, condition = compile_comparison(tokens, i + 1, label)
    assert tokens[i] == "INDENT"
    i, then_branch = compile_statements(tokens, i + 1)
    assert tokens[i] == "DEINDENT"
    assert tokens[i + 1] == "else"
    assert tokens[i + 2] == "INDENT"
    i, else_branch = compile_statements(tokens, i + 3)
    assert tokens[i] == "DEINDENT"
    code = f"{condition}{then_branch}jmp {label}_end\n"
    code += f"{label}_else:\n{else_branch}{label}_end:\n"
    return i + 1, code


def compile_comparison(tokens, i, if_name):
    i, expr1 = compile_expression(tokens, i)
    operator = tokens[i]
    assert operator in {"<", ">", "<=", ">="}
    i, expr2 = compile_expression(tokens, i + 1)
    code = expr1 + expr2 + "pop bx\npop ax\ncmp ax, bx\n"
    operator = {">": "<=", "<": ">=", ">=": "<", "<=": ">"}[operator]
    jmp = {"<": "JL", ">": "JG", "<=": "JLE", ">=": "JGE"}[operator]
    return i, code + f"{jmp} {if_name}_else\n"


def compile_declaration(tokens, i):
    global variables
    var_type = tokens[i]
    variable = tokens[i + 1]
    if variable in variables:
        warnging(f"{variable} is already defined")
    assert tokens[i + 2] == "="
    value = tokens[i + 3]
    variables[variable] = var_type
    typ = {"int": "dw", "i8": "db", "i8[]": "db"}[var_type]
    return i + 4, f"{variable} {typ} {value}\n"


def compile_expression(tokens: List[str], i: int, target_type: str = "int"):
    i, code = compile_term(tokens, i, target_type)
    while tokens[i] in "+-":
        operator = tokens[i]
        i, expr = compile_term(tokens, i + 1, target_type)
        code += expr
        if target_type == "int":
            if operator == "+":
                code += "pop bx\npop ax\nadd ax, bx\npush ax\n"
            else:
                code += "pop bx\npop ax\nsub ax, bx\npush ax\n"
        else:
            if operator == "+":
                code += "pop bl\npop al\nadd al, bl\npush al\n"
            else:
                code += "pop bl\npop al\nsub al, bl\npush al\n"
    return i, code


def compile_term(tokens, i, target_type):
    i, code = compile_factor(tokens, i, target_type)
    while tokens[i] in "*/":
        operator = tokens[i]
        i, expr = compile_factor(tokens, i + 1, "int")
        code += expr
        if target_type is "int":
            if operator == "*":
                code += "pop bx\npop ax\nimul bx\npush ax\n"
            else:
                code += "pop bx\npop ax\ncwd\nidiv bx\npush ax\n"
        else:
            code += "pop al\ncbw\nmov bx, ax\n"
            if operator == "*":
                code += "pop ax\nimul bx\npush al\n"
            else:
                code += "pop ax\ncwd\nidiv bx\npush al\n"
    return i, code


def compile_factor(tokens, i, target_type):
    if tokens[i] == "(":
        i, code = compile_expression(tokens, i + 1, target_type)
        return i + 1, code
    if tokens[i].isdigit():
        literal = tokens[i]
        if target_type == "int":
            return i + 1, f"mov ax, {literal}\npush ax\n"
        return i + 1, f"mov al, {literal}\npush al\n"
    variable = tokens[i]
    assert variable in variables, variable
    if target_type == "int":
        if variables[variable] == "int":
            return i + 1, f"mov ax, {variable}\npush ax\n"
        if variables[variable] == "i8":
            return i + 1, f"mov al, {variable}\ncbw\npush ax\n"
    else:
        if variables[variable] == "int":
            return i + 1, f"mov ax, {variable}\npush al\n"
        if variables[variable] == "i8":
            return i + 1, f"mov al, {variable}\npush al\n"
    assert False, f"What to do with {variable}:{variables[variable]}?"


def optimize_assembly(assembly: str):
    lines = []
    for line in assembly.split("\n"):
        if line == "pop ax":
            if lines[-1] == "push ax":
                lines.pop()
            elif lines[-1] == "push bx":
                lines[-1] = "mov ax, bx"
            else:
                lines.append(line)
        elif line == "pop bx":
            if lines[-1] == "push bx":
                lines.pop()
            elif lines[-1] == "push ax":
                lines[-1] = "mov bx, ax"
            else:
                lines.append(line)
        else:
            lines.append(line)
    return "\n".join(lines)

def prettify_assembly(assembly: str):
    lines = []
    for line in assembly.strip().split("\n"):
        if line and not line.endswith(":"):
            line = "\t" + line
        lines.append(line)
    return "\n".join(lines)


source = """
int a = 8
int b = 3
i8 c = 5
i8 d = -2
int RES = 0

def main():
    if a * d >= 0
        RES = b - ( c + a / d ) * b
    else
        RES = a / b + c - d * a
"""

source = """
i8 a = 3
i8 b = 5
i8 y = 0

def main()
    ay = a + b
"""
print(prettify_assembly(optimize_assembly(compile(source))))
